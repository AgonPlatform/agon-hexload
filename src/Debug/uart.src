; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optsize -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\uart.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",4
.DEFINE "dr"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "ddr"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "alt1"
.VALUE 2
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "alt2"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",6
.DEFINE "baudRate"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "dataBits"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stopBits"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "parity"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME1"
;    1	/*
;    2	 * Title:			AGON - Loadable UART1 code
;    3	 * Author:			Jeroen Venema, original by Dean Belfeld
;    4	 * Created:			06/01/2023
;    5	 * Last Updated:	06/01/2023
;    6	 * 
;    7	 * The UART1 is on Port C
;    8	 *
;    9	 * - Port C0: TX
;   10	 * - Port C1: RX
;   11	 */
;   12	 
;   13	#include <stddef.h>
;   14	#include <stdio.h>
;   15	#include <eZ80.h>
;   16	#include <defines.h>
;   17	#include <gpio.h>
;   18	
;   19	#include "uart.h"
;   20	 
;   21	// Set the Line Control Register for data, stop and parity bits
;   22	//
;   23	#define SETREG_LCR1(data, stop, parity) (UART1_LCTL = ((BYTE)(((data)-(BYTE)5)&(BYTE)0x3)|(BYTE)((((stop)-(BYTE)0x1)&(BYTE)0x1)<<(BYTE)0x2)|(BYTE)((parity)<<(BYTE)0x3)))
;   24	
;   25	VOID init_UART1() {
_init_UART1:
.DEFINE "_init_UART1"

.VALUE _init_UART1

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "init_UART1",25,"_init_UART1"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   26		PC_DR = PORTC_DRVAL_DEF;
.LINE 26

	LD	A,%FF
	OUT0	(158),A
;   27		PC_DDR = PORTC_DDRVAL_DEF;
.LINE 27

	OUT0	(159),A
;   28		PC_ALT1 = PORTC_ALT1VAL_DEF;
.LINE 28

	XOR	A,A
	OUT0	(160),A
;   29		PC_ALT2 = PORTC_ALT2VAL_DEF;
.LINE 29

	XOR	A,A
	OUT0	(161),A
;   30		return ;
;   31	}
.LINE 31

	LD	SP,IX
	POP	IX
	RET	


;**************************** _init_UART1 ***************************
;Name                         Addr/Register   Size   Type


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "init_UART1",31,"_init_UART1"
;   32	
;   33	// Open UART
;   34	// Parameters:
;   35	// - pUART: Structure containing the initialisation data
;   36	//
;   37	UCHAR open_UART1(UART *pUART) {
_open_UART1:
.DEFINE "_open_UART1"

.VALUE _open_UART1

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "open_UART1",37,"_open_UART1"

.LINE 37

.DEFINE "pUART"

.CLASS 65

.VALUE 6

.TAG "NONAME1"

.TYPE 40

.ENDEF

.DEFINE "br"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;   38		UINT16	br = MASTERCLOCK / (CLOCK_DIVISOR_16 * pUART->baudRate);//! Compute the baudrate generator value;
.LINE 38

	LD	IY,(IX+%6)
	LD	HL,(IY+%0)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	CALL	__itol
	LD	HL,3222784
	LD	E,%1
	CALL	__ldivs
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;   39		UCHAR	pins = PORTPIN_ZERO | PORTPIN_ONE;						//! The transmit and receive pins
;   40		
;   41		SETREG(PC_DDR, pins);											//! Set Port C bits 0, 1 (TX. RX) for alternate function.
.LINE 41

	IN0	A,(159)
	OR	A,%3
	OUT0	(159),A
;   42		RESETREG(PC_ALT1, pins);
.LINE 42

	IN0	A,(160)
	AND	A,%FC
	OUT0	(160),A
;   43		SETREG(PC_ALT2, pins);
.LINE 43

	IN0	A,(161)
	OR	A,%3
	OUT0	(161),A
;   44		
;   45		SETREG(PC_DDR, PORTPIN_THREE);									//! Set Port C bit 3 (CTS) for input
.LINE 45

	IN0	A,(159)
	SET	%3,A
	OUT0	(159),A
;   46		RESETREG(PC_ALT1, PORTPIN_THREE);
.LINE 46

	IN0	A,(160)
	RES	%3,A
	OUT0	(160),A
;   47		RESETREG(PC_ALT2, PORTPIN_THREE);
.LINE 47

	IN0	A,(161)
	RES	%3,A
	OUT0	(161),A
;   48		
;   49		UART1_LCTL |= UART_LCTL_DLAB ;									//! Select DLAB to access baud rate generators
.LINE 49

	IN0	A,(211)
	SET	%7,A
	OUT0	(211),A
;   50		UART1_BRG_L = (br & 0xFF) ;										//! Load divisor low
.LINE 50

	LD	A,(IX+%FFFFFFFE)
	OUT0	(208),A
;   51		UART1_BRG_H = (CHAR)(( br & 0xFF00 ) >> 8) ;					//! Load divisor high
.LINE 51

	LD	HL,(IX+%FFFFFFFE)
	LD	L,H
	LD	H,%0
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	OUT0	(209),A
;   52		UART1_LCTL &= (~UART_LCTL_DLAB) ; 								//! Reset DLAB; dont disturb other bits
.LINE 52

	IN0	A,(211)
	RES	%7,A
	OUT0	(211),A
;   53		UART1_MCTL = 0x00 ;												//! Bring modem control register to reset value.
.LINE 53

	XOR	A,A
	OUT0	(212),A
;   54		UART1_FCTL = 0x07 ;												//! Disable hardware FIFOs.
.LINE 54

	LD	A,%7
	OUT0	(210),A
;   55		UART1_IER = UART_IER_RECEIVEINT ;
.LINE 55

	LD	A,%1
	OUT0	(209),A
;   56		
;   57		SETREG_LCR1(pUART->dataBits, pUART->stopBits, pUART->parity);	//! Set the line status register.
.LINE 57

	LD	A,(IY+%4)
	DEC	A
	AND	A,%1
	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	A,(IY+%3)
	SUB	A,%5
	AND	A,%3
	LD	B,A
	LD	A,C
	OR	A,B
	LD	C,A
	LD	A,(IY+%5)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,C
	OR	A,B
	OUT0	(211),A
;   58		
;   59		return UART_ERR_NONE ;
.LINE 59

	XOR	A,A
;   60	}
.LINE 60

	LD	SP,IX
	POP	IX
	RET	


;**************************** _open_UART1 ***************************
;Name                         Addr/Register   Size   Type
;br                                    IX-2      2   variable
;pUART                                 IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "open_UART1",60,"_open_UART1"
;   61	
;   62	VOID uart1_puts(CHAR *str)
;   63	{
_uart1_puts:
.DEFINE "_uart1_puts"

.VALUE _uart1_puts

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "uart1_puts",63,"_uart1_puts"

.LINE 63

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;   64		while(*str)	uart1_putch(*str++);
.LINE 64

	JR	L_3
L_4:
	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
	LD	HL,(IX+%FFFFFFFD)
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_uart1_putch
	POP	BC
L_3:
	LD	HL,(IX+%6)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_4
;   65	}
.LINE 65

	LD	SP,IX
	POP	IX
	RET	


;**************************** _uart1_puts ***************************
;Name                         Addr/Register   Size   Type
;_uart1_putch                        IMPORT  -----   function
;str                                   IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "uart1_puts",65,"_uart1_puts"
	XREF _uart1_putch:ROM
	XREF __ldivs:ROM
	XREF __stoiu:ROM
	XREF __itol:ROM
	XDEF _uart1_puts
	XDEF _open_UART1
	XDEF _init_UART1
	END
