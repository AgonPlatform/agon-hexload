Zilog eZ80 Macro Assembler Version 4.3 (19073001) RELISTED06-Jan-23     16:18:23     page:   1


PC     Object              I  Line    Source 
                           A     1    ;
                           A     2    ; Title:	Hello World - Initialisation Code
                           A     3    ; Author:	Dean Belfield
                           A     4    ; Created:	22/11/2022
                           A     5    ; Last Updated: 25/11/2022
                           A     6    ;
                           A     7    ; Modinfo:
                           A     8    ; 25/11/2022:	Added parameter parsing; now ac
                           A     9    
                           A    10    			SEGMENT CODE
                           A    11    			
                           A    12    			XREF	__low_bss
                           A    13    			XREF	__len_bss
                           A    14    			
                           A    15    			XREF	_main
                           A    16    			.ASSUME	ADL = 1	
                           A    17    
       00000010            A    18    argv_ptrs_max:		EQU	16			; Maximum n
                           A    19    
                           A    20    ;
                           A    21    ; Start in ADL mode
                           A    22    ;
                           A    23    
0B0000 C3 45 00 0B         A    24    			JP	_start			; Jump to start
                           A    25    
                           A    26    ;
                           A    27    ; The header stuff
                           A    28    ;
0B0004 4845584C 4F41442E   A    29    _exec_name:		DB	"HEXLOAD.BIN", 0		; T
0B000C 42494E00 
                           A    30    
                           A    31    			ALIGN	64			; The executabl
                           A    32    			
0B0040 4D4F53              A    33    			DB	"MOS"			; Flag for MOS 
0B0043 00                  A    34    			DB	00h			; MOS header versio
0B0044 01                  A    35    			DB	01h			; Flag for run mode
                           A    36    
                           A    37    ;
                           A    38    ; And the code follows on immediately after the
                           A    39    ;
0B0045 F5                  A    40    _start:			PUSH	AF			; Preserve 
0B0046 C5                  A    41    			PUSH	BC
0B0047 D5                  A    42    			PUSH	DE
0B0048 DDE5                A    43    			PUSH	IX
0B004A FDE5                A    44    			PUSH	IY			; Need to prese
                           A    45    ;			
0B004C E5                  A    46    			PUSH	HL			; Clear the RAM
0B004D CD 6E 00 0B         A    47    			CALL	_clear_bss
0B0051 E1                  A    48    			POP	HL
                           A    49    ;
0B0052 DD21 F6 0E 0B       A    50    			LD	IX, argv_ptrs		; The argv 
0B0057 DDE5                A    51    			PUSH	IX			; Parameter 2: 
0B0059 CD 8D 00 0B         A    52    			CALL	_parse_params		; Parse
0B005D 0600                A    53    			LD	B, 0			; Clear B from 
0B005F C5                  A    54    			PUSH	BC			; Parameter 1: 
0B0060 CD D7 00 0B         A    55    			CALL	_main			; int main(
0B0064 D1                  A    56    			POP	DE			; Balance the stack
0B0065 D1                  A    57    			POP	DE
0B0066 FDE1                A    58    			POP	IY			; Restore registers
0B0068 DDE1                A    59    			POP	IX
0B006A D1                  A    60    			POP	DE
0B006B C1                  A    61    			POP 	BC
0B006C F1                  A    62    			POP	AF
0B006D C9                  A    63    			RET
                           A    64    			
                           A    65    ; Clear the memory
                           A    66    ;
0B006E 01 2A 04 00         A    67    _clear_bss:		LD	BC, __len_bss		; Check
0B0072 3E 00               A    68    			LD	a, __len_bss >> 16
0B0074 B1                  A    69    			OR	A, C
0B0075 B0                  A    70    			OR	A, B
0B0076 C8                  A    71    			RET	Z			; BSS is zero-lengt
0B0077 AF                  A    72    			XOR	A, A
0B0078 32 82 0F 0B         A    73    			LD 	(__low_bss), A
0B007C ED62                A    74    			SBC	HL, HL			; HL = 0
0B007E 0B                  A    75    			DEC	BC			; 1st byte's taken 
0B007F ED42                A    76    			SBC	HL, BC
0B0081 C8                  A    77    			RET	Z		  	; Just 1 byte ...
0B0082 21 82 0F 0B         A    78    			LD	HL, __low_bss		; Reset HL
0B0086 11 83 0F 0B         A    79    			LD	DE, __low_bss + 1	; [DE] = bs
0B008A EDB0                A    80    			LDIR				; Clear this se
0B008C C9                  A    81    			RET
                           A    82    			
                           A    83    ; Parse the parameter string into a C array
                           A    84    ; Parameters
                           A    85    ; - HL: Address of parameter string
                           A    86    ; - IX: Address for array pointer storage
                           A    87    ; Returns:
                           A    88    ; - BC: Number of parameters parsed
                           A    89    ;
0B008D 01 04 00 0B         A    90    _parse_params:		LD	BC, _exec_name
0B0091 DD0F00              A    91    			LD	(IX+0), BC		; ARGV[0] = the
0B0094 DD23                A    92    			INC	IX
0B0096 DD23                A    93    			INC	IX
0B0098 DD23                A    94    			INC	IX
                           A    95    ;
0B009A 01010000            A    96    			LD	BC, 1			; C: ARGC = 1 -
0B009E 060F                A    97    			LD	B, argv_ptrs_max - 1	; B: Ma
                           A    98    ;
0B00A0 C5                  A    99    $$:			PUSH	BC			; Stack ARGC
0B00A1 CD D0 00 0B         A   100    			CALL	_skip_spaces		; Skip 
0B00A5 E5                  A   101    			PUSH	HL			; Stack start a
0B00A6 CD C1 00 0B         A   102    			CALL	_get_token		; Get the n
0B00AA 79                  A   103    			LD	A, C			; A: Length of 
0B00AB D1                  A   104    			POP	DE			; Start address of 
0B00AC C1                  A   105    			POP	BC			; ARGC
0B00AD B7                  A   106    			OR	A			; Check for A=0 (no
0B00AE C8                  A   107    			RET	Z
                           A   108    ;
0B00AF 3600                A   109    			LD	(HL), 0			; Zero-terminat
0B00B1 23                  A   110    			INC	HL			; And skip onto the
0B00B2 DD1F00              A   111    			LD	(IX+0), DE		; Store the poi
0B00B5 DD23                A   112    			INC	IX
0B00B7 DD23                A   113    			INC	IX
0B00B9 DD23                A   114    			INC	IX			; Advance to next p
0B00BB 0C                  A   115    			INC	C			; Increment ARGC
0B00BC 79                  A   116    			LD	A, C			; Check for C >
0B00BD B8                  A   117    			CP	B
0B00BE 38 E0               A   118    			JR	C, $B			; And loop
0B00C0 C9                  A   119    			RET
                           A   120    
                           A   121    ; Get the next token
                           A   122    ; Parameters:
                           A   123    ; - HL: Address of parameter string
                           A   124    ; Returns:
                           A   125    ; - HL: Address of first character after token
                           A   126    ; -  C: Length of token (in characters)
                           A   127    ;
0B00C1 0E00                A   128    _get_token:		LD	C, 0			; Initialis
0B00C3 7E                  A   129    $$:			LD	A, (HL)			; Get the chara
0B00C4 B7                  A   130    			OR	A			; Exit if 0 (end of
0B00C5 C8                  A   131    			RET 	Z
0B00C6 FE0D                A   132    			CP	13			; Exit if CR (end o
0B00C8 C8                  A   133    			RET	Z
0B00C9 FE20                A   134    			CP	' '			; Exit if space (en
0B00CB C8                  A   135    			RET	Z
0B00CC 23                  A   136    			INC	HL			; Advance to next c
0B00CD 0C                  A   137    			INC 	C			; Increment len
0B00CE 18 F3               A   138    			JR	$B
                           A   139    	
                           A   140    ; Skip spaces in the parameter string
                           A   141    ; Parameters:
                           A   142    ; - HL: Address of parameter string
                           A   143    ; Returns:
                           A   144    ; - HL: Address of next none-space character
                           A   145    ;
0B00D0 7E                  A   146    _skip_spaces:		LD	A, (HL)			; Get t
0B00D1 FE20                A   147    			CP	' '			; Exit if not space
0B00D3 C0                  A   148    			RET	NZ
0B00D4 23                  A   149    			INC	HL			; Advance to next c
0B00D5 18 F9               A   150    			JR	_skip_spaces		; Increment
                           A   151    
                           A   152    
                           A   153    			SEGMENT DATA
                           A   154    
                           A   155    
                           A   156    ; Storage for the argv array pointers
                           A   157    ;
0B0EF6 000000 000000       A   158    argv_ptrs:		BLKP	argv_ptrs_max, 0
0B0EFC 000000 000000 
0B0F02 000000 000000 
0B0F08 000000 000000 
0B0F0E 000000 000000 
0B0F14 000000 000000 
0B0F1A 000000 000000 
0B0F20 000000 000000 
                           A   159    			
                           A   160    			END


Errors: 0
Warnings: 0
Lines Assembled: 161
